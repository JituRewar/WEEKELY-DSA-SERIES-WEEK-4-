# Day 2 — Three Sum (LeetCode 15)


**Problem:** Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.


Triplets must not be repeated — each unique combination should appear only once (order within a triplet does not matter).


---


### Approach (two-pointer after sorting)
1. Sort the array.
2. Iterate `i` from `0` to `n-3`. For each `i`, use two pointers `l = i+1` and `r = n-1` to find pairs where `nums[i] + nums[l] + nums[r] == 0`.
3. Skip duplicates for `i`, `l`, and `r` to ensure unique triplets.


This is the standard O(n^2) solution.


---


### Time & Space Complexity
- Time: O(n^2)
- Space: O(log n) or O(n) depending on sorting implementation and output size


---


### File
  c++
  class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
       int n=nums.size();
       vector<vector<int>> ans;
       sort(nums.begin(),nums.end());
       for(int i=0;i<n;i++){
        if(i>0 && nums[i]==nums[i-1]) continue;
        int j=i+1,k=n-1;
        while(j<k){
            int sum=nums[i]+nums[j]+nums[k];
            if(sum<0){
                j++;
            }
            else if(sum>0){
                k--;
            }
            else{
                //sum==0
                ans.push_back({nums[i],nums[j],nums[k]});
                j++;
                k--;
                while(j<k && nums[j]==nums[j-1]) j++;
            }
        }

       }
       return ans;
    }
};
